{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block head %}
  {{ block.super }}
  <style>
    .get-example {
      display: none;
    }
    dt {
      display: block;
      margin: 0;
      font-weight: bold;
      color: #333;
    }
    dd {
      margin: 0 0 0.8em;
    }

    dl.inline dt {
      display: inline;
    }
    dl.inline dd {
      display: inline;
    }
    dl.inline dd::before {
      content:" - ";
    }
    dl.inline dd::after {
      content:"\A";
      white-space:pre;
    }
  </style>
{% endblock %}

{% block content %}

<p>신사 숙녀 여러분 웹 개발의 역사에 있어 가장 중요한 순간이 왔습니다....</p>
<p><em>[두구두구두구]</em></p>
<p>드디어 자바스크립트에서 프라미스(Promise)를 네이티브 지원합니다!</p>
<p><em>[불꽃이 폭발하고, 꽃가루가 날리고, 사람들이 환호합니다]</em></p>
<p>여러분은 다음 세 부류 중 하나에 속할 것입니다.</p>

<ul>
  <li>사람들이 주변에서 기뻐하고 있지만, 대체 이게 무슨 소란인지 알 수가 없습니다. 아마도 "프라미스(Promise-약속이란 뜻이란것은 알겠지만)"이 뭔지도 모를 것입니다. 어깨를 으쓱하고 그냥 무시할 수도 있습니다. 하지만 두 어깨에 느껴지는 색종이의 무게감은 어쩔 수 없지요. 걱정하지 마십시오. 저 자신도 왜 내가 이 주제에 관심을 기울여야 하는지 이해하는데 한참 걸렸습니다. 이런 분은 <a href="#toc-async">여기서부터 시작하는 것이 좋습니다.</a></li>
  <li>주먹을 하늘로 휘두릅니다! 제때 프라미스가 나온건가요? 아마도 프라미스를 예전에 사용해 보긴 했지만 구현마다 API가 달라서 조금 망설였을 것입니다. 공식 자바스크립트 버전의 API는 무엇일까요? 이런 분은 <a href="#toc-promise-terminology">여기서 시작하면 될 것입니다.</a></li>
  <li>이 사실을 이미 알고 있고, 옆에서 기뻐하는 다른 사람들이 이를 이제야 알았다는게 한심합니다. 우월감을 누려볼 시간이네요. 그 후 <a href="#toc-api">API 참조문서를 보세요.</a></li>
</ul>

<h2 id="toc-async">대체 이게 무슨 일인가?</h2>

<p>자바스크립트는 단일 쓰레드입니다. 따라서 두 스크립트가 동시에 실행될 수가 없습니다. 한 부분이 실행되고 나면 다른 부분이 순차적으로 실해되어야 합니다. 브라우저에서 자바스크립트는 다른 여러 기능과 쓰레드를 공유합니다. 이렇게 한 쓰레드를 공유하는 기능은 브라우저마다 다릅니다. 보통 자바 스크립트는 화면 그리기, 스타일 변경, (텍스트를 강조하거나 폼 콘트롤과 상호작용 하는 등) 사용자의 활동 처리 등과 쓰레드를 같이 씁니다. 따라서 이런 기능 중 어느 한 부분의 동작은 다른 기능들을 지연시킬 수 있습니다.</p>
<p>인간인 여러분은 다중쓰레드입니다. 여러 손가락으로 키보드를 칠 수도 있고, 차를 운전하는 동시에 다른 사람과 대화할 수도 있습니다. 인간의 동작 중 다른 활동을 블럭하는 유일한 기능은 재채기입니다. 재채기를 하는 동안에는 다른 모든 것을 잠시 중단할 수밖에 없습니다. 이는 아주 성가신 일입니다. 특히나 운전중이거나 대화를 나누는 중이라면 말이죠. 재채기를 하는 코드를 작성하고 싶은 사람은 없을 겁니다. </p>
<p>이벤트와 그 이벤트를 처리하기 위한 콜백를 사용해 본 적이 있을겁니다. 다음은 이벤트의 예입니다.</p>

<pre class="prettyprint">var img1 = document.querySelector('.img-1');
  
img1.addEventListener('load', function() {
  // 울랄라.. 이미지가 로딩되었네
});

img1.addEventListener('error', function() {
  // 아~~악. 에러가 나 버렸다
});</pre>

<p>이런 코드는 재채기를 하고 있지 않습니다. 이미지를 가지고 와서 리스너를 추가했고, 자바스크립트는 리스너 중 하나가 호출될 때까지는 실행될 필요가 없기 때문에 쓰레드는 다른 작업을 할 수 있습니다.</p>
<p>불행하게도 위의 예제에서 이벤트가 리스너를 추가하기 전에 발생했을 수도 있습니다. 따라서 이미지의 "complete" 프로퍼티를 사용해 이런 경우를 처리해야만 합니다.</p>

<pre class="prettyprint">var img1 = document.querySelector('.img-1');

function loaded() {
  // 울랄라.. 이미지가 로딩되었네
}

if (img1.complete) {
  loaded();
}
else {
  img1.addEventListener('load', loaded);
}

img1.addEventListener('error', function() {
  // 아~~악. 에러가 나 버렸다
});</pre>

<p>이런 방식은 리스너를 달기 전에 오류가 발생한 이미지를 잡아낼 수가 없습니다. 불행히도 DOM에서는 이를 처리할 방법이 없습니다. 또한 위 예제는 단지 이미지를 하나만 로드하지만, 이미지 갯수가 많아지면 문제가 훨씬 더 복잡해집니다.</p>

<h2 id="toc-events-not-always-best">이벤트로 처리하는게 항상 최선의 방법은 아닙니다</h2>

<p>이벤트는 키 들림(key up), 터치 시작 등 동일한 객체에 여러 번 발생하는 사건을 처리하는 경우에 잘 들어맞습니다. 이러한 이벤트의 경우 리스너를 붙이기 전에 발생한 사건에 대해서는 실제로 관심이 없습니다. 하지만 비동기적인 성공/실패를 검사하는 경우, 이상적으로는 다음과 같은 것이 필요할 수도 있습니다.</p>

<pre class="prettyprint">img1.callThisIfLoadedOrWhenLoaded(function() {
  // 이미지 로드됨
}).orIfFailedCallThis(function() {
  // 실패함
});

// 그리고...
whenAllTheseHaveLoaded([img1, img2]).callThis(function() {
  // 모두 로드됨
}).orIfSomeFailedCallThis(function() {
  // 하나 이상 실패함 
});</pre>

<p>이게 바로 프라미스가 해주는 일입니다. 다만, 더 이해하기 쉬운 이름을 사용할 뿐이죠. 만약 HTML 이미지 엘리먼트에 프라미스를 반환하는 "ready" 메소드가 있었다면 같은 일을 다음과 같이 하면 되었을 겁니다.</p>

<pre class="prettyprint">img1.ready().then(function() {
  // 로드됨
}, function() {
  // 실패함
});

// and…
Promise.all([img1.ready(), img2.ready()]).then(function() {
  // 모두 로드됨
}, function() {
  // 하나 이상 실패함
});</pre>

<p>기초적인 프라미스는 다음 사항을 제외하면 이벤트 리스터와 어느정도 비슷합니다.</p>

<ul>
  <li>프라미스는 단 한번만 성공 또는 실패합니다. 프라미스는 여러번 성공하거나 실패할 수 없고, 성공한 프라미스가 실패로 바뀌거나, 실패한 프라미스가 성공으로 바뀌는 일이 없습니다.</li>
  <li>어떤 프라미스가 완료(성공 또는 실패가 일어남)한 다음에, success/failure 콜백을 연결하는 경우 완료 상태에 따른 콜백이 호출됩니다. 해당 이벤트가 콜백 연결 전에 발생한 경우라도 그렇습니다.</li>
</ul>

<p>이런 특징은 비동기적인 성공/실패의 경우 아주 유용합니다. 왜냐하면 성공이나 실패가 일어난 시각이 언젠가는 그리 중요하지 않고, 결과 자체가 더 중요하기 때문입니다.</p>

<h2 id="toc-promise-terminology">프라미스 용어 정리</h2>

<p><a href="https://twitter.com/domenic">도미닉 데니콜라(Domenic Denicola)</a>가 내가 쓴 이 글의 초고를 검토하고는 용어 설명 부분에 "F"를 주었습니다. 그리고, 나를 정학을 시키고, <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and Fates</a>를 100번 베껴쓰게 하고, 우리 부모님께 상담 편지를 보냈습니다. 그럼에도 불구하고 제 머릿속에는 여러 개념이 뒤섞여 있습니다. 하지만 몇가지 기본적인 용어는 다음과 같습니다.</p>

<p>프라미스의 상태는 다음 중 하나 입니다.</p>
<dl class="inline">
  <dt>fulfilled(만족함)</dt>
  <dd>프라미스의 동작이 성공으로 완료됨</dd>
  <dt>rejected(거부됨)</dt>
  <dd>프라미스의 동작이 실패로 완료됨</dd>
  <dt>pending(대기중)</dt>
  <dd>아직 결과가 나오지 않음(즉, 만족하거나 거부되지 않음)</dd>
  <dt>settled(완료됨)</dt>
  <dd>이미 결과가 나옴(즉, 만족하거나 거부 상태가 이미 결정됨)</dd>
</dl>

<p>명세에서는 <strong>thenable</strong> 용어를 써서 프라미스와 비슷하며 "then" 메소드를 지원하는 객체들을 지칭합니다. 이 용어를 들으면 예전 잉글랜드 축구 대표팀 감독 <a href="http://en.wikipedia.org/wiki/Terry_Venables">테리 베나블즈(Terry Venables)</a>가 생각납니다.  그래서 가급적 이 말을 사용하지 않을 것입니다(역주: 테리 베나블즈는 1994년 월드컵에서 실망스러웠던 잉글랜드 팀을 이어받은 국대 감독시절 영국서 열린 유로 '96에서 잉글랜드를 4강에 올리고, 리즈가 재정난으로 붕괴하기 직전의 리즈시절 막판 감독을 역임하기도 했습니다. 아마도 저자가 이 분의 팬인것 같습니다).</p>

<h2 id="toc-javascript-promises">프라미스가 자바스크립트에 왔어요!</h2>
<p>물론 자바시크립트에서는 이전에도 라이브러리 형태로 프라미스가 사용되어 왔습니다.</p>

<ul>
  <li><a href="https://github.com/kriskowal/q">Q</a></li>
  <li><a href="https://github.com/cujojs/when">when</a></li>
  <li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">WinJS</a></li>
  <li><a href="https://github.com/tildeio/rsvp.js">RSVP.js</a></li>
</ul>

<p>위에 열거한 자바스크립트 프라미스들은 표준 동작 <a href="https://github.com/promises-aplus/promises-spec">Promises/A+</a>를 공유합니다. jQuery 사용자라면 비슷한 것을 <a href="http://api.jquery.com/category/deferred-object/">Deferred</a>라 부르겠지요. 하지만 Deferred는 Promise/A+를 준수하지 않습니다. 그래서 Deferred는 <a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/">아주 많이 다르고, 그리 유용하지도 않습니다.</a> 따라서, 조심하기 바랍니다. 또한 jQuery에는 <a href="http://api.jquery.com/Types/#Promise">Promise라는 타입</a>도 존재합니다. 하지만, 이는 Deferred의 부분 집합이며, Deferred와 똑같은 문제점을 공유합니다.</p>
<p>프라미스 구현들이 표준적인 행동 양식을 따르긴 하지만, 이들의 API는 서로 차이가 있습니다. 자바스크립트 프라미스 API는 RSVP.js의 API와 비슷합니다. 프라미스는 다음과 같이 만들 수 있습니다.</p>

<pre class="prettyprint">var promise = new Promise(function(resolve, reject) {
  // 무언가 작업을 합니다. 보통 비동기적인 일을 하지요.
  
  if (/* 모든 일이 순조롭게 잘 마무리되었습니다. */) {
    resolve("잘 동작했습니다!");
  }
  else {
    reject(Error("어딘가 잘못되었습니다."));
  }
});</pre>

<p>프라미스의 생성자는 콜백을 하나 받습니다. 그 콜백에는 두 매개변수 resolve와 reject가 있습니다. 콜백 내부에서 필요한 (아마도 비동기) 작업을 한 다음에, 잘 마무리되었다면 resolve를, 그렇지 않다면 reject를 호출하면 됩니다.</p>
<p>일반 자바스크립트에서 "throw"로 예외를 던지는 것처럼, 오류 발생시 Error 객체를 가지고 reject하는 것이 관습이긴 합니다만, 필수적인 사항은 아닙니다. Error 객체를 사용하면 스택 트레이스를 잡아서 디버깅에 유용하게 쓸 수 있다는 장점이 있습니다.</p>
<p>위와 같이 만든 프라미스는 다음과 같이 사용할 수 있습니다.</p>

<pre class="prettyprint">promise.then(function(result) {
  console.log(result); // "Stuff worked!"
}, function(err) {
  console.log(err); // Error: "It broke"
});</pre>

<p>"then" takes two arguments, a callback for a success case, and another for the failure case. Both are optional, so you can add a callback for the success or failure case only.</p>
<p>JavaScript promises started out in the DOM as "Futures", renamed to "Promises", and finally moved into JavaScript. Having them in JavaScript rather than the DOM is great because they'll be available in non-browser JS contexts such as Node.js (whether they make use of them in their core APIs is another question).</p>
<p>Although they're a JavaScript feature, the DOM isn't afraid to use them. In fact, all new DOM APIs with async success/failure methods will use promises. This is happening already with <a href="https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html#idl-def-StorageQuota">Quota Management</a>, <a href="http://dev.w3.org/csswg/css-font-load-events/#dom-fontface-ready">Font Load Events</a>,<a href="https://github.com/slightlyoff/ServiceWorker/blob/cf459d473ae09f6994e8539113d277cbd2bce939/service_worker.ts#L17"> ServiceWorker</a>, <a href="http://webaudio.github.io/web-midi-api/#widl-Navigator-requestMIDIAccess-Promise-MIDIOptions-options">Web MIDI</a>, <a href="https://github.com/whatwg/streams#basereadablestream">Streams</a>, and more.</p>

<h2 id="toc-browser-support">Browser support &amp; polyfill</h2>
<p>There are already (partial) implementations of promises in browsers today.</p>
<p>When in Chrome, do as the Chromans do. <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Download Canary</a>, which has promises enabled by default. Alternatively, if you're of the Firefox persuasion, <a href="http://nightly.mozilla.org/">grab their latest nightly</a>, which also features promises.</p>

<p>Neither has a complete or fully compliant implementation. You can track <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=918806">Firefox's development on bugzilla</a>, and <a href="http://www.chromestatus.com/features/5681726336532480">Chrome's on the feature dashboard</a>.</p>
<p>To bring those browsers up to spec compliance, or add promises to other browsers and Node.js, check out <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md">the polyfill</a> (2k gzipped).</p>

<h2 id="toc-lib-compatibility">Compatibility with other libraries</h2>
<p>The JavaScript promises API will treat anything with a "then" method as promise-like (or <em>thenable</em> in promise-speak <em>*sigh*</em>), and with the exception of <code>Promise.cast</code> there's no distinction made between JavaScript promise instances and things that are promise-like. So if you use a library that returns a Q promise, that's fine, it'll play nice with the new JavaScript promises.</p>
<p>Although, as I mentioned, jQuery's Deferreds are a bit… unhelpful. Thankfully you can cast them to standard promises, which is worth doing as soon as possible:</p>

<pre class="prettyprint">var jsPromise = Promise.cast($.ajax('/whatever.json'));</pre>

<p>Here, jQuery's <code>$.ajax</code> returns a Deferred. Since it has a "then" method, <code>Promise.cast</code> can turn it into a JavaScript promise. However, sometimes deferreds pass multiple arguments to their callbacks, eg:</p>

<pre class="prettyprint">var jqDeferred = $.ajax('/whatever.json');

jqDeferred.then(function(response, statusText, xhrObj) {
  // ...
}, function(xhrObj, textStatus, err) {
  // ...
});</pre>

<p>Whereas JS promises ignore all but the first:</p>

<pre class="prettyprint">jsPromise.then(function(response) {
  // ...
}, function(xhrObj) {
  // ...
});</pre>

<p>…thankfully this is usually what you want, or at least gives you access to what you want. Also, be aware that jQuery doesn't follow the convention of passing Error objects into rejections.</p>

<h2 id="toc-coding-with-promises">Complex async code made easier</h2>
<p>Right, let's code some things. Say we want to:</p>

<ol>
  <li>Start a spinner to indicate loading</li>
  <li>Fetch some JSON for a story, which gives us the title, and urls for each chapter</li>
  <li>Add title to the page</li>
  <li>Fetch each chapter</li>
  <li>Add the story to the page</li>
  <li>Stop the spinner</li>
</ol>

<p>…but also tell the user if something went wrong along the way. We'll want to stop the spinner at that point too, else it'll keep on spinning, get dizzy, and crash into some other UI.</p>
<p>Of course, you wouldn't use JavaScript to deliver a story, <a href="http://jakearchibald.com/2013/progressive-enhancement-is-faster/">serving as HTML is faster</a>, but this pattern is pretty common when dealing with APIs: Multiple data fetches, then do something when it's all done.</p>
<p>To start with, let's deal with fetching data from the network:</p>

<h2 id="toc-promisifying-xmlhttprequest">Promisifying XMLHttpRequest</h2>

<p>Old APIs will be updated to use promises, if it's possible in a backwards compatible way. <code>XMLHttpRequest</code> is a prime candidate, but in the mean time let's write a simple function to make a GET request:</p>

<pre class="prettyprint">function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error("Network Error"));
    };

    // Make the request
    req.send();
  });
}</pre>

<p>Now let's use it:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.error("Failed!", error);
});</pre>

<p><span class="live-example get-example"><a href="story.json">Click here to see that in action</a>, check the console in DevTools to see the result.</span> Now we can make HTTP requests without manually typing <code>XMLHttpRequest</code>, which is great, because the less I have to see the infuriating camel-casing of <code>XMLHttpRequest</code>, the happier my life will be.</p>

<h2 id="toc-chaining">Chaining</h2>
<p>"then" isn't the end of the story, you can chain "then"s together to transform values or run additional async actions one after another.</p>

<h3 id="toc-transforming-values">Transforming values</h2>
<p>You can transform values simply by returning the new value:</p>

<pre class="prettyprint">var promise = new Promise(function(resolve, reject) {
  resolve(1);
});

promise.then(function(val) {
  console.log(val); // 1
  return val + 2;
}).then(function(val) {
  console.log(val); // 3
});</pre>

<p>As a practical example, let's go back to:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Success!", response);
});</pre>

<p>The response is JSON, but we're currently receiving it as plain text. We could alter our get function to use the JSON <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#responseType">responseType</a></code>, but we could also solve it in promises land:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  return JSON.parse(response);
}).then(function(response) {
  console.log("Yey JSON!", response);
});</pre>

<p>Since <code>JSON.parse</code> takes a single argument and returns a transformed value, we can make a shortcut:</p>

<pre class="prettyprint">get('story.json').then(JSON.parse).then(function(response) {
  console.log("Yey JSON!", response);
});</pre>

<p><span class="live-example json-example"><a href="story.json">Click here to see that in action</a>, check the console in DevTools to see the result.</span> In fact, we could make a <code>getJSON</code> function really easily:</p>

<pre class="prettyprint">function getJSON(url) {
  return get(url).then(JSON.parse);
}</pre>

<p><code>getJSON</code> still returns a promise, one that fetches a url then parses the response as JSON.</p>

<h3 id="toc-promises-queues">Queuing asynchronous actions</h2>
<p>You can also chain "then"s to run async actions in sequence.</p>
<p>When you return something from a "then" callback, it's a bit magic. If you return a value, the next "then" is called with that value. However, if you return something promise-like, the next "then" waits on it, and is only called when that promise settles (succeeds/fails). For example:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  console.log("Got chapter 1!", chapter1);
});</pre>

<p>Here we make an async request to "story.json", which gives us a set of URLs to request, then we request the first of those. This is when promises really start to stand out from simple callback patterns.
  
  You could even make a shortcut method to get chapters:</p>

<pre class="prettyprint">var storyPromise;

function getChapter(i) {
  storyPromise = storyPromise || getJSON('story.json');
  
  return storyPromise.then(function(story) {
    return getJSON(story.chapterUrls[i]);
  })
}

// and using it is simple:
getChapter(0).then(function(chapter) {
  console.log(chapter);
  return getChapter(1);
}).then(function(chapter) {
  console.log(chapter);
});</pre>

<p>We don't download "story.json" until <code>getChapter</code> is called, but the next time(s) <code>getChapter</code> is called we reuse the story promise, so story.json is only fetched once. Yay Promises!</p>

<h2 id="toc-error-handling">Error handling</h2>
<p>As we saw earlier, "then" takes two arguments, one for success, one for failure (or fulfill and reject, in promises-speak):</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.log("Failed!", error);
});</pre>

<p>You can also use "catch":</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Success!", response);
}).catch(function(error) {
  console.log("Failed!", error);
});</pre>

<p>There's nothing special about "catch", it's just sugar for <code>then(undefined, func)</code>, but it's more readable. Note that the two code examples above do not behave the same, the latter is equivalent to:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Success!", response);
}).then(undefined, function(error) {
  console.log("Failed!", error);
});</pre>

<p>The difference is subtle, but extremely useful. Promise rejections skip forward to the next "then" with a rejection callback (or "catch", since it's equivalent). With <code>then(func1, func2)</code>, <code>func1</code> or <code>func2</code> will be called, never both. But with <code>then(func1).catch(func2)</code>, both will be called if <code>func1</code> rejects, as they're separate steps in the chain. Take the following:</p>

<pre class="prettyprint">asyncThing1().then(function() {
  return asyncThing2();
}).then(function() {
  return asyncThing3();
}).catch(function(err) {
  return asyncRecovery1();
}).then(function() {
  return asyncThing4();
}, function(err) {
  return asyncRecovery2();
}).catch(function(err) {
  console.log("Don't worry about it");
}).then(function() {
  console.log("All done!");
});</pre>

<p>The flow above is very similar to normal JavaScript try/catch, errors that happen within a "try" go immediately to the "catch" block. Here's the above as a flowchart (because I love flowcharts):</p>

<div style="max-width: 495px; margin: 10px auto">
  <div style="position: relative; padding-top: 93%;">
    <iframe style="position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden" src="promise-flow.svg" frameborder="0" allowtransparency="true"></iframe>
  </div>
</div>

<p>Follow the green lines for promises that fulfill, or the red for ones that reject.</p>

<h3 id="toc-exceptions-and-promises">JavaScript exceptions and promises</h3>
<p>Rejections happen when a promise is explicitly rejected, but also implicitly if an error is thrown in the constructor callback:</p>

<pre class="prettyprint">var jsonPromise = new Promise(function(resolve, reject) {
  // JSON.parse throws an error if you feed it some
  // invalid JSON, so this implicitly rejects:
  resolve(JSON.parse("This ain't JSON"));
});

jsonPromise.then(function(data) {
  // This never happens:
  console.log("It worked!", data);
}).catch(function(err) {
  // Instead, this happens:
  console.log("It failed!", err);
});</pre>

<p>This means it's useful to do all your promise-related work inside the promise constructor callback, so errors are automatically caught and become rejections.</p>
<p>The same goes for errors thrown in "then" callbacks.</p>

<pre class="prettyprint">get('/').then(JSON.parse).then(function() {
  // This never happens, '/' is an HTML page, not JSON
  // so JSON.parse throws
  console.log("It worked!", data);
}).catch(function(err) {
  // Instead, this happens:
  console.log("It failed!", err);
});</pre>

<h3 id="toc-errors-in-practice">Error handling in practice</h3>

<p>With our story and chapters, we can use catch to display an error to the user:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  addHtmlToPage(chapter1.html);
}).catch(function() {
  addTextToPage("Failed to show chapter");
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>If fetching <code>story.chapterUrls[0]</code> fails (eg http 500 or user is offline), it'll skip all following success callbacks, which includes the one in <code>getJSON</code> which tries to parse the response as JSON, and also skips the callback that adds chapter1.html to the page. Instead it moves onto the catch callback. As a result, "Failed to show chapter" will be added to the page if any of the previous actions failed.</p>
<p>Like JavaScript's try/catch, the error is caught and subsequent code continues, so the spinner is always hidden, which is what we want. The above becomes a non-blocking async version of:</p>

<pre class="prettyprint">try {
  var story = getJSONSync('story.json');
  var chapter1 = getJSONSync(story.chapterUrls[0]);
  addHtmlToPage(chapter1.html);
}
catch (e) {
  addTextToPage("Failed to show chapter");
}

document.querySelector('.spinner').style.display = 'none';</pre>

<p>You may want to "catch" simply for logging purposes, without recovering from the error. To do this, just rethrow the error. We could do this in our <code>getJSON</code> method:</p>

<pre class="prettyprint">function getJSON(url) {
  return get(url).then(JSON.parse).catch(function(err) {
    console.log("getJSON failed for", url, err);
    throw err;
  });
}</pre>

<p>So we've managed to fetch one chapter, but we want them all. Let's make that happen.</p>

<h2 id="toc-parallelism-sequencing">Parallelism and sequencing - Getting the best of both</h2>

<p>Thinking async isn't easy. If you're struggling to get off the mark, try writing the code as if it were synchronous. In this case:</p>

<pre class="prettyprint">try {
  var story = getJSONSync('story.json');
  addHtmlToPage(story.heading);

  story.chapterUrls.forEach(function(chapterUrl) {
    var chapter = getJSONSync(chapterUrl);
    addHtmlToPage(chapter.html);
  });

  addTextToPage("All done");
}
catch (err) {
  addTextToPage("Argh, broken: " + err.message);
}

document.querySelector('.spinner').style.display = 'none';</pre>

<p>That works (<a href="sync-example.html">see example</a>)! But it's sync and locks up the browser while things download. To make this work async we use "then" to make things happen one after another.</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // TODO: for each url in story.chapterUrls, fetch &amp; display
}).then(function() {
  // And we're all done!
  addTextToPage("All done");
}).catch(function(err) {
  // Catch any error that happened along the way
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  // Always hide the spinner
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>But how can we loop through the chapter urls and fetch them in order? This <strong>doesn't work</strong>:</p>

<pre class="prettyprint">story.chapterUrls.forEach(function(chapterUrl) {
  // Fetch chapter
  getJSON(chapterUrl).then(function(chapter) {
    // and add it to the page
    addHtmlToPage(chapter.html);
  });
});</pre>

<p>"forEach" isn't async-aware, so our chapters would appear in whatever order they download, which is basically how Pulp Fiction was written. This isn't Pulp Fiction, so let's fix it…</p>

<h3 id="toc-creating-sequences">Creating a sequence</h3>
<p>We want to turn our <code>chapterUrls</code> array into a sequence of promises. We can do that using "then":</p>

<pre class="prettyprint">// Start off with a promise that always resolves
var sequence = Promise.resolve();

// Loop through our chapter urls
story.chapterUrls.forEach(function(chapterUrl) {
  // Add these actions to the end of the sequence
  sequence = sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
});</pre>

<p>This is the first time we've seen <code>Promise.resolve</code>, which creates a promise that resolves to whatever value you give it. If you pass it something promise-like (has a 'then' method), it creates a new promise that fulfills/rejects in the same way, effectively a clone. If you pass in any other value, eg <code>Promise.resolve('Hello')</code>, it creates a promise that fulfills with that value. If you call it with no value, as above, it fulfills with "undefined".</p>

<p>There's also <code>Promise.reject(val)</code>, which creates a promise that rejects with the value you give it (or undefined).</p>
<p>We can tidy up the above code using <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">array.reduce</a></code>:</p>

<pre class="prettyprint">// Loop through our chapter urls
story.chapterUrls.reduce(function(sequence, chapterUrl) {
  // Add these actions to the end of the sequence
  return sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
}, Promise.resolve());</pre>

<p>This is doing the same as the previous example, but doesn't need the separate "sequence" variable. Our reduce callback is called for each item in the array. "sequence" is <code>Promise.resolve()</code> the first time around, but for the rest of the calls "sequence" is whatever we returned from the previous call. <code>array.reduce</code> is really useful for boiling an array down to a single value, which in this case is a promise.</p>
<p>Let's put it all together…</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  return story.chapterUrls.reduce(function(sequence, chapterUrl) {
    // Once the last chapter's promise is done…
    return sequence.then(function() {
      // …fetch the next chapter
      return getJSON(chapterUrl);
    }).then(function(chapter) {
      // and add it to the page
      addHtmlToPage(chapter.html);
    });
  }, Promise.resolve());
}).then(function() {
  // And we're all done!
  addTextToPage("All done");
}).catch(function(err) {
  // Catch any error that happened along the way
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  // Always hide the spinner
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>And there we have it (<a href="async-example.html">see example</a>), a fully async version of the sync version. But we can do better. At the moment our page is downloading like this:</p>

<figure>
  <img src="promise1.gif">
</figure>

<p>Browsers are pretty good at downloading multiple things at once, so we're losing performance by downloading chapters one after the other. What we want to do is download them all at the same time, then process them when they've all arrived. Thankfully there's an API for this:</p>

<pre class="prettyprint">Promise.all(arrayOfPromises).then(function(arrayOfResults) {
  //...
});</pre>

<p><code>Promise.all</code> takes an array of promises and creates a promise that fulfills when all of them successfully complete. You get an array of results (whatever the promises fulfilled to) in the same order as the promises you passed in.</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // Take an array of promises and wait on them all
  return Promise.all(
    // Map our array of chapter urls to
    // an array of chapter json promises
    story.chapterUrls.map(getJSON)
  );
}).then(function(chapters) {
  // Now we have the chapters jsons in order! Loop through…
  chapters.forEach(function(chapter) {
    // …and add to the page
    addHtmlToPage(chapter.html);
  });
  addTextToPage("All done");
}).catch(function(err) {
  // catch any error that happened so far
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Depending on connection, this can be seconds faster than loading one-by-one (<a href="async-all-example.html">see example</a>), and it's less code than our first try. The chapters can download in whatever order, but they appear on screen in the right order.</p>

<figure>
  <img src="promise2.gif">
</figure>

<p>However, we can still improve perceived performance. When chapter one arrives we should add it to the page. This lets the user start reading before the rest of the chapters have arrived. When chapter three arrives, we wouldn't add it to the page because the user may not realise chapter two is missing. When chapter two arrives, we can add chapters two and three, etc etc.</p>
<p>To do this, we fetch JSON for all our chapters at the same time, then create a sequence to add them to the document:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // Map our array of chapter urls to
  // an array of chapter json promises.
  // This makes sure they all download parallel.
  return story.chapterUrls.map(getJSON)
    .reduce(function(sequence, chapterPromise) {
      // Use reduce to chain the promises together,
      // adding content to the page for each chapter
      return sequence.then(function() {
        // Wait for everything in the sequence so far,
        // then wait for this chapter to arrive.
        return chapterPromise;
      }).then(function(chapter) {
        addHtmlToPage(chapter.html);
      });
    }, Promise.resolve());
}).then(function() {
  addTextToPage("All done");
}).catch(function(err) {
  // catch any error that happened along the way
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>And there we go (<a href="async-best-example.html">see example</a>), the best of both! It takes the same amount of time to deliver all the content, but the user gets the first bit of content sooner.</p>

<figure>
  <img src="promise3.gif">
</figure>

<p>In this trivial example, all of the chapters arrive around the same time, but the benefit of displaying one at a time will be exaggerated with more, larger chapters.</p>

<p>Doing the above with <a href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce">Node.js-style callbacks or events</a> is around double the code, but more importantly isn't as easy to follow. However, this isn't the end of the story for promises, when combined with other ES6 features they get even easier…</p>

<h2 class="toc-generators">Bonus round: Promises and Generators</h2>

<p>This next bit involves a whole bunch of new ES6 features, but it's not something you need to understand to use promises in your code today. Treat it like a movie trailer for some upcoming blockbuster features.</p>
<p>ES6 also gives us <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">generators</a>, which allow functions to exit at a particular point, like "return", but later resume from the same point and state. Eg:</p>

<pre class="prettyprint">function *addGenerator() {
  var i = 0;
  while (true) {
    i += yield i;
  }
}</pre>

<p>Notice the star before the function name, this makes it a generator. The yield keyword is our return/resume point. We can use it like this:</p>

<pre class="prettyprint">var adder = addGenerator();
adder.next().value; // 0
adder.next(5).value; // 5
adder.next(5).value; // 10
adder.next(5).value; // 15
adder.next(50).value; // 65</pre>

<p>But what does this mean for promises? Well, you can use this return/resume behaviour to write async code that looks (and is as easy to follow as) synchronous code. Don't worry too much about understanding it line-for-line, but here's a helper function that lets us use 'yield' to wait for promises to settle:</p>

<pre class="prettyprint">function spawn(generatorFunc) {
  function continuer(verb, arg) {
    var result;
    try {
      result = generator[verb](arg);
    } catch (err) {
      return Promise.reject(err);
    }
    if (result.done) {
      return result.value;
    } else {
      return Promise.cast(result.value).then(onFulfilled, onRejected);
    }
  }
  var generator = generatorFunc();
  var onFulfilled = continuer.bind(continuer, "next");
  var onRejected = continuer.bind(continuer, "throw");
  return onFulfilled();
}</pre>

<p>…which I pretty much <a href="https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500">lifted verbatim from Q</a>, but adapted for JavaScript promises. With this, we can take our final best-case chapter example, mix it with a load of new ES6 goodness, and turn it into:</p>

<pre class="prettyprint">spawn(function *() {
  try {
    // 'yield' effectively does an async wait,
    // returning the result of the promise
    let story = yield getJSON('story.json');
    addHtmlToPage(story.heading);

    // Map our array of chapter urls to
    // an array of chapter json promises.
    // This makes sure they all download parallel.
    let chapterPromises = story.chapterUrls.map(getJSON);

    for (let chapterPromise of chapterPromises) {
      // Wait for each chapter to be ready, then add it to the page
      let chapter = yield chapterPromise;
      addHtmlToPage(chapter.html);
    }

    addTextToPage("All done");
  }
  catch (err) {
    // try/catch just works, rejected promises are thrown here
    addTextToPage("Argh, broken: " + err.message);
  }
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>This works exactly as before, but so much easier to read. This works in Chrome Canary today (<a href="async-generators-example.html">see example</a>), but first you need to go to <strong>about:flags</strong> and turn on <strong>Enable experimental JavaScript</strong>.</p>

<p>This throws together a lot of new ES6 stuff: promises, generators, let, for-of. When we yield a promise, the spawn helper waits for the promise to resolve and returns the final value. If the promise rejects, spawn causes our yield statement to throw an exception, which we can catch with normal JavaScript try/catch. Amazingly simple async coding!</p>

<h2 id="toc-api">Promise API Reference</h2>

<p>All methods work in the nightly versions of Chrome and Firefox unless otherwise noted. <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md">The polyfill</a> provides the below for all browers.</p>

<h3>Static Methods</h3>
<dl>
  <dt><code>Promise.cast(promise);</code></dt>
  <dd>Returns promise (only if <code>promise.constructor == Promise</code>)
  <p class="notice"><b>Note:</b> Only implemented in Chrome so far</p></dd>
  <dt><code>Promise.cast(obj);</code></dt>
  <dd>Make a promise that fulfills to obj.
  <p class="notice"><b>Note:</b> Only implemented in Chrome so far</p></dd>
  <dt><code>Promise.resolve(thenable);</code></dt>
  <dd>Make a new promise from the thenable. A thenable is promise-like in as far as it has a "then" method. This also creates a new promise if you pass it a genuine JavaScript promise, making it less efficient for casting than <code>Promise.cast</code>.
  <p class="notice"><b>Note:</b> Chrome incorrectly calls this <code>Promise.resolved</code></p>
  </dd>
  <dt><code>Promise.resolve(obj);</code></dt>
  <dd>Make a promise that fulfills to obj. Same as <code>Promise.cast(obj)</code> in this situation.
    <p class="notice"><b>Note:</b> Chrome incorrectly calls this <code>Promise.resolved</code></p></dd>
  <dt><code>Promise.reject(obj);</code></dt>
  <dd>Make a promise that rejects to obj. For consistency and debugging (eg stack traces), obj should be an <code>instanceof Error</code>
  <p class="notice"><b>Note:</b> Chrome incorrectly calls this <code>Promise.rejected</code></p>
  <dt>
  <dt><code>Promise.all(array);</code></dt>
  <dd>Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects. Eadd array item is passed to Promise.cast, so the array can be a mixture of promise-like objects and other objects. The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
  <p class="notice"><b>Note:</b> Only implemented in Chrome so far</p></dd>
  <dt><code>Promise.race(array);</code></dt>
  <dd>Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
  <p class="notice"><b>Note:</b> Only implemented in Chrome as <code>Promise.one</code>. Also, I'm unconvinced of it's usefulness, I'd rather have an opposite of <code>Promise.all</code> that only rejected if all items rejected.</p></dd>
</dl>

<h3>Constructor</h3>
<pre class="prettyprint">new Promise(function(resolve, reject) {});</pre>
<dl>
  <dt><code>resolve(thenable)</code></dt>
  <dd>Your promise will be fulfilled/rejected with the outcome of <code>thenable</code></dd>
  <dt><code>resolve(obj)</code></dt>
  <dd>Your promise is fulfilled with <code>obj</code></dd>
  <dt><code>reject(obj)</code></dt>
  <dd>Your promise is rejected with <code>obj</code>. For consistency and debugging (eg stack traces), obj should be an <code>instanceof Error</code>. Any errors thrown in the constructor callback will be implicitly passed to <code>reject()</code>.</dd>
</dl>

<h3>Instance Methods</h3>
<dl>
  <dt><code>promise.then(onFulfilled, onRejected)</code></dt>
  <dd><code>onFulfilled</code> is called when/if "promise" resolves.
  <code>onRejected</code> is called when/if "promise" rejects.
  Both are optional, if either/both are omitted the next <code>onFulfilled</code>/<code>onRejected</code> in the chain is called.
  Both callbacks have a single parameter , the fulfillment value or rejection reason.
  "then" returns a new promise equivalent to the value you return from <code>onFulfilled</code>/<code>onRejected</code> after being passed through <code>Promise.resolve</code>. If an error is thrown in the callback, the returned promise rejects with that error.</dd>
  <dt><code>promise.catch(onRejected)</code></dt>
  <dd>Sugar for <code>promise.then(undefined, onRejected)</code></dd>
</dl>

<p>Many thanks to Anne van Kesteren, Domenic Denicola, Tom Ashworth, Remy Sharp, Addy Osmani, Arthur Evans, and Yutaka Hirano who proofread this and made corrections/recommendations.</p>

<script src="promise-2.0.4.min.js"></script>
<script>
  function get(url) {
    // Return a new promise.
    // We do all the work within the constructor callback, so we can return here
    return new Promise(function(resolve, reject) {
      // Do the usual XHR stuff
      var req = new XMLHttpRequest();
      req.open('GET', url);

      req.onload = function() {
        // This is called even on 404 etc
        // so check the status
        if (req.status == 200) {
          // Resolve the promise with the response text
          resolve(req.response);
        }
        else {
          // Otherwise reject with the status text
          // which will hopefully be a meaningful error
          reject(Error(req.statusText));
        }
      };

      // Handle network errors
      req.onerror = function() {
        reject(Error("Network Error"));
      };

      // Make the request
      req.send();
    });
  }

  Array.prototype.slice.call(document.querySelectorAll('.live-example')).forEach(function(el) {
    el.style.display = "inline";
  });

  document.querySelector('.get-example a').addEventListener('click', function(event) {
    if (event.button !== 0) {
      return;
    }

    get(this.href).then(
      console.log.bind(console, "Success!"),
      console.error.bind(console, "Failure!")
    );
    event.preventDefault();
  });

  document.querySelector('.json-example a').addEventListener('click', function(event) {
    if (event.button !== 0) {
      return;
    }

    get(this.href).then(JSON.parse).then(
      console.log.bind(console, "Success!"),
      console.error.bind(console, "Failure!")
    );
    event.preventDefault();
  });
</script>

{% endblock %}
